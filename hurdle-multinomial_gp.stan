// Hurdle-Multinomial model, modified from code generated by brms
functions {

  /* compute a latent Gaussian process
  * Args:
  *   x: array of continuous predictor values
  *   sdgp: marginal SD parameter
  *   lscale: length-scale parameter
  *   zgp: vector of independent standard normal variables
  * Returns:
  *   a vector to be added to the linear predictor
  */
  vector gp(vector[] x, real sdgp, real lscale, vector zgp) {
    int N = size(x);
    matrix[N, N] cov;
    // one dimensional or isotropic GP
    cov = cov_exp_quad(x, sdgp, lscale);
    for (n in 1:N) {
      // deal with numerical non-positive-definiteness
      cov[n, n] += 1e-12;
    }
    return cholesky_decompose(cov) * zgp;
  }


  /* zero-inflated multinomial log-PDF of a single response
  * logit parameterization of the zero-inflation part
  * softmax parameterization of the multinomial response (See https://mc-stan.org/docs/2_18/functions-reference/softmax.html)
  * Args:
  *   y[]: vector of integer responses
  *   eta: linear predictor for hurdle - positive response triggers multinomial
  *   theta[]: vector of linear predictors for the multinomial part - first assumed to be zeros
  * Returns:
  *   a scalar to be added to the log posterior
  */
  real hurdle_multinomial_logit_softmax_lpmf(int[] y, real eta, vector theta) {

    /*If all the responses are of the first type, this can occur either through not passing
    the hurdle or all multinomial responses being of that type. */
    if (sum(y[2:size(y)]) == 0) {
      return log_sum_exp(bernoulli_logit_lpmf(0 | eta), // Note the log_sum_exp fuction adds logs on the linear scale - so adding the first output of (0|eta) with the second (1|eta)+ multinomial - it's used for the hurdle - either hurdle is zero
      bernoulli_logit_lpmf(1 | eta) + //Note bernoulli_logit_lpmf is the normal logistic regression logit transformation of a Bernoulli distribution; or hurdle is 1, but there were no deaths or abortions
      multinomial_lpmf(y | softmax(theta)));
    } else {
      return bernoulli_logit_lpmf(1 | eta) +
      multinomial_lpmf(y | softmax(theta));
    }
  }

  // This allows us to export the softmax function to R
  vector rsoftmax(vector x) {
    return softmax(x);
  }
}
data {
  int<lower=1> N;  // number of observations
  int<lower=2> ncat;  // number of categories
  int Y[N, ncat];  // response array

  int<lower=1> K;  // number of population-level effects (multinomial)
  matrix[N, K] X;  // population-level design matrix (multinomial)

  int<lower=1> K_eta;  // number of population-level effects (hurdle)
  matrix[N, K_eta] X_eta;  // population-level design matrix (hurdle)

  // data related to GPs (used only for hurdle)
  int<lower=1> Dgp;  // GP dimension
  // covariates of the GP
  vector[Dgp] Xgp[N];

  vector[N] outbreak; // outbreak data to calculate residuals
  vector[N] num_animals;// number of animals data to calculate residuals


  int prior_only;  // should the likelihood be ignored?
}
parameters {
  vector[K] b_1;  // population-level effects for first outcome
  vector[K] b_2;  // population-level effects for second outcome
  vector[K_eta] b_eta;  // population-level hurdle effects
  // GP standard deviation parameters
  real<lower=0> sdgp;
  // GP length-scale parameters
  real<lower=0> lscale;
  // latent variables of the GP at each data point on the normal scale
  vector[N] zgp;

}
transformed parameters {

  // initalize linear predictor terms for outcomes (theta and eta)
  vector[N] eta;
  vector[ncat] theta[N];
  // initialize terms for GP individual effects
  vector[N] gp_eff;
  vector[N]eta_noGP;

  // calculate linear predictors

  // By declaring theta_1 and theta_2 in a local of sub-block, their values
  // are not exported and reduce the model export size
  {
    vector[N] theta_1 = X * b_1;
    vector[N] theta_2 = X * b_2;
    // Assemble multinomial linear predictors into a vector of vectors
    for (n in 1:N) {
      theta[n] = [0, theta_1[n], theta_2[n]]';
    }
  }

  gp_eff =  gp(Xgp, sdgp, lscale, zgp);
  eta = X_eta * b_eta + gp_eff;
  eta_noGP = X_eta * b_eta;
}
model {
  //priors for fixed effects (student's t-distribution)
  target += student_t_lpdf(b_1 | 3, 0, 10);
  target += student_t_lpdf(b_2 | 3, 0, 10);
  target += student_t_lpdf(b_eta | 3, 0, 10);

  // Prior for GP SD (half student's t)
  target += student_t_lpdf(sdgp | 3, 0, 10) - 1 * student_t_lccdf(0 | 3, 0, 10);//also called alpha - corresponds to how much of the variation is explained by the regression function and has a similar role to the prior variance for linear model weights
  // Prior for scale parameter
  target += inv_gamma_lpdf(lscale | 1.839943, 0.114937);//inverse gamma avoids infintesimal length scales; inversegamma(alpha, beta) like gamma distribution; ok because we are not including coordinates as fixed and/or random effects
  // Prior for individual GP effects
  target += normal_lpdf(zgp | 0, 1);//This is a latent variable gaussian process; when the outcome isn't normal

  // likelihood including all constants
  if (!prior_only) {
    for (n in 1:N) {
      target += hurdle_multinomial_logit_softmax_lpmf(Y[n] | eta[n], theta[n]);
    }
  }
}
generated quantities {

  /* define predictions and residuals */
  // initalize linear predictor terms for outcomes (theta and eta)
  vector[N] resid_eta;
  vector[N] resid_theta_2;
  vector[N] resid_theta_3;
  vector[N] eta_hat;
  vector[ncat] theta_hat[N];
  vector[N] log_lik;



  /* calculate predictions (hat) and residuals */
  {
    for(n in 1:N){
      theta_hat[n] = inv_logit(eta[n]) * num_animals[n] * softmax(theta[n]);

    }
    eta_hat = inv_logit(eta);


    resid_eta = outbreak - eta_hat;
    for(n in 1:N){
      resid_theta_2[n] = Y[n][2] - theta_hat[n][2];
    }

    for(n in 1:N){
      resid_theta_3[n] = Y[n][3] - theta_hat[n][3];
    }
  }
  //log likelihood for WAIC evalutaion
  for (n in 1:N){
    log_lik[n] = hurdle_multinomial_logit_softmax_lpmf(Y[n] | eta[n], theta[n]);
  }
}

